// @ts-nocheck
/**
 * 题目：
 * 现有三根柱子a、b、c，a 柱上套有若干个圆盘，这些圆盘大小各异，按从大到小的顺序自下而上摆放。
 * 现在要把套在 a 柱子上的圆盘全部转移到 c 柱上，并且在移动圆盘时必须遵守以下规则：
    1、一次只能移动柱子最上端的一个圆盘
    2、小圆盘上不能放大圆盘
    将一个圆盘从一根柱子移到另一根柱子，算移动“1次”，那么，将若干个圆盘全部从 a 移到 c 最少需要移动几次呢? 2^n - 1次
    算法题让你描述步骤
 */

 /**
  * 思路：
  * 递归过程，通过某种方法先把 n-1 个圆盘放在辅助柱子上，然后把目前最大的圆盘放在目标柱子上，最后把辅助柱子上那 n-1 个圆盘放在目标柱子。
  * 对于 n-1 个圆盘怎么放到的呢？ 假设先把 n-2 个圆盘放在辅助柱子上，然后把目前最大的圆盘放在当前目标柱子上，最后把 n-2 个圆盘再挪回目标柱子。
  * 再假如，只有 2 个圆盘，先把最小的那个放在辅助柱子上，然后把最大的放在目标柱子上，最后把辅助柱子上那个放在目标柱子上。这样理解了吧。
  * 这样是不是就造成了递归？
  * 递归的出口就是当只有一个圆盘的时候，直接挪到目标柱子上就行。
  * 
  * 
  */

/**
 * 
 * @param { 圆盘个数 } n 
 * @param { 起始放盘柱子 } origin 
 * @param { 辅助柱子} helper 
 * @param { 目标柱子 } target 
 * @param { 移动步骤的数组 } move 
 * 返回值是移动次数
 */
export default function hanoi(n, origin, helper, target, move = []) {
  if(n === 0) {
    console.log('一个盘子都木有，你移动啥移动...')
  }
  if (n === 1) { // 递归出口
    console.log(`${origin} -> ${target}`) // 直接把起始的盘子绕过辅助柱子直接移到目标柱子
    move.push([origin, target])
  } else {
    hanoi(n-1, origin, target, helper, move) // 把 n-1 个盘子从起始绕过目标柱子移到辅助柱子
    console.log(`${origin} -> ${target}`) // 把当前最大的盘子从起始柱子直接移到目标柱子
    move.push([origin, target])
    hanoi(n-1, helper, origin, target, move) // 再把 n-1 个盘子从辅助柱子绕过起始柱子移到目标柱子
  }
  return move.length
}
